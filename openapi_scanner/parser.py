import cgi
import copy
import functools
import urllib.parse as urlparse
from logging import getLogger
from typing import Any, Optional

import requests
import yaml

from . import __package_name__
from .constants import USER_AGENT

logger = getLogger(__package_name__)


class Resolver:
    """Кеширует спецификации"""

    YAML_MIMES: list[str] = [
        'text/vnd.yaml',
        'application/yaml',
        'application/x-yaml',
        'text/x-yaml',
    ]

    YAML_EXTS: tuple[str, ...] = ('.yml', '.yaml')

    def __init__(self, session: Optional[requests.Session] = None):
        self._session = session or self._create_session()
        self._cache = {}

    def _create_session(self) -> requests.Session:
        s = requests.session()
        s.headers.update({'User-Agent': USER_AGENT})
        return s

    def resolve(self, specification_url: str) -> dict[str, Any]:
        if specification_url not in self._cache:
            r = self._session.get(specification_url)
            ct, _ = cgi.parse_header(r.headers.get('content-type', ''))
            if ct in self.YAML_MIMES or specification_url.endswith(
                self.YAML_EXTS
            ):
                specification = yaml.safe_load(r.text)
            else:
                specification = r.json()
            self._cache[specification_url] = specification
        return self._cache[specification_url]

    __call__ = resolve


class Dereferencer:
    def __init__(
        self, specification_url: str, resolver: None | Resolver = None
    ):
        self._specification_url = specification_url
        self._resolver = resolver or Resolver()
        # self._specification = self._resolver(specification_url))

    # Эти методы должны принадлежать парсеру, но парсер мы выбираем исходя из структуры
    # документа

    # Допусти, что $ref может быть в любом месте
    def dereference(self) -> dict[str, Any]:
        return self._dereference(
            self._resolver.resolve(self._specification_url)
        )

    __call__ = dereference

    def _dereference(self, o: Any, backrefs: list[str] = []) -> Any:
        if isinstance(o, dict):
            rv = {}
            for k, v in o.items():
                if k == '$ref':
                    if v in backrefs:
                        raise ValueError('Circular reference detected: %r', o)
                    backrefs.append(v)
                    rv.update(
                        self._dereference(self._resolve_reference(v), backrefs)
                    )
                    assert backrefs.pop() == v
                    # Все после $ref должно игнорироваться
                    break
                rv[k] = self._dereference(v, backrefs)
            return rv
        if isinstance(o, list):
            return [self._dereference(x, backrefs) for x in o]
        assert isinstance(o, (int, float, str, bool))
        return o

    def _resolve_reference(self, ref: str) -> Any:
        url, path = ref.split('#', 2)
        specification = self._resolver(
            urlparse.urljoin(self._specification_url, url)
        )
        rv = specification
        for key in path.split('/')[1:]:
            key = key.replace('~1', '/').replace('~0', '~')
            rv = rv[key]
        return rv


class BaseParser:
    pass


class SwaggerParser(BaseParser):
    ALLOWED_METHODS: set[str] = {
        'get',
        'head',
        'post',
        'put',
        'patch',
        'delete',
        'options',
        'trace',
    }

    # По идее тут параметр specification лишний, так как мы всегда можем через loader получить схему по URL
    def __init__(
        self,
        specification: dict[str, Any],
        specification_url: str,
    ):
        self._specification = specification
        self._specification_url = specification_url

    def get_server_urls(self) -> list[str]:
        base_path = self._specification.get('basePath', '/')
        if host := self._specification.get('host'):
            return [
                f'{scheme}://{host}{base_path}'.rstrip('/')
                for scheme in self._specification['schemes']
            ]
        return [
            urlparse.urljoin(self._specification_url, base_path).rstrip('/')
        ]

    def get_paths(self) -> list[str]:
        return list(self._specification['paths'].keys())

    def get_operations(self, path: str) -> list[str]:
        return list(
            set(self._specification['paths'][path].keys())
            & self.ALLOWED_METHODS
        )

    def get_parameters(self, path: str, operation: str) -> list[dict[str, Any]]:
        path_object = self._specification['paths'][path]
        defaults = path_object.get('parameters', {})
        path_item = path_object[operation]
        params = path_item.get('parameters', {})
        params = self._override_parameters(defaults, params)
        return copy.deepcopy(params)

    def filter_parameters(
        self, path: str, operation: str, location: str
    ) -> list[dict[str, Any]]:
        return list(
            filter(
                lambda x: x['in'] == location,
                self.get_parameters(path, operation),
            )
        )

    get_path_parameters = functools.partialmethod(
        filter_parameters, location='path'
    )
    get_query_parameters = functools.partialmethod(
        filter_parameters, location='query'
    )
    get_header_parameters = functools.partialmethod(
        filter_parameters, location='header'
    )
    get_body_parameters = functools.partialmethod(
        filter_parameters, location='body'
    )
    get_formdata_parameters = functools.partialmethod(
        filter_parameters, location='formData'
    )

    def has_payload(self, path: str, operation: str) -> bool:
        parameters = self.get_parameters(path, operation)
        return any(lambda x: x['in'] in ('body', 'formData'), parameters)

    def has_formdata(self, path: str, operation: str) -> bool:
        parameters = self.get_parameters(path, operation)
        return any(lambda x: x['in'] == 'formData', parameters)

    def get_payload_mimes(self, path: str, operation: str) -> list[str]:
        # Принимаемые типы можно объявить в корне и переопределить в Operation
        consumes = self._specification.get('consumes', [])
        # копируем объекты во избежание их модификации
        return list(
            self._specification['paths'][path][operation].get(
                'consumes', consumes
            )
        )

    def _override_parameters(
        self, defaults: list[dict[str, Any]], overrides: list[dict[str, Any]]
    ) -> list[dict[str, Any]]:
        make_key = lambda x: (x.get('name'), x.get('in'))
        out = {make_key(v): v for v in defaults}
        for v in overrides:
            out[make_key(v)] = v
        return list(out.values())


# https://api.data.amsterdam.nl/signals/swagger/openapi.yaml
class OpenApiParser(SwaggerParser):
    def get_server_urls(self) -> list[str]:
        servers = self._specification.get('servers', [])
        # Правильно ли?
        urls = [x['url'] for x in servers] if servers else ['/']
        return [
            urlparse.urljoin(self._specification_url, u).rstrip('/')
            for u in urls
        ]

    get_cookie_parameters = functools.partialmethod(
        SwaggerParser.filter_parameters, location='cookie'
    )

    def get_request_body(
        self, path: str, operation: str, mime: None | str = None
    ) -> list[dict[str, Any]] | dict[str, Any] | None:
        rv = self._specification['paths'][path][operation].get(
            'requestBody', {}
        )
        if mime:
            rv = rv.get('content', {}).get(mime)
        return copy.deepcopy(rv)

    def get_payload_mimes(self, path: str, operation: str) -> list[str]:
        return list(
            self.get_request_body(path, operation).get('content', {}).keys()
        )

    def has_payload(self, path: str, operation: str) -> bool:
        return len(self.get_payload_mimes(path, operation)) > 0


# Примеры ссылок на спецификацию:
# - https://app.andfrankly.com/api/data/swagger.yml (2)
# - https://railgun.spatialcurrent.io/swagger.yml (2)
# - https://navigationservice.e-spirit.cloud/docs/api/swagger-files/swagger.yml (3)
# - https://api.weather.gov/openapi.json (3)
# - https://www.skylinesoft.com/KB_Resources/PM/WebHelp/API/openapi.json (3)
# - https://coda.io/apis/v1/openapi.json (3)
# - https://georg.nrm.se/api/swagger.json (2)
# - https://michael1011.at/git/michael1011/market-maker-bot/src/branch/feat/reserved-balance/src/proto/xudrpc.swagger.json (2)
def create_parser(specification_url: str) -> SwaggerParser | OpenApiParser:
    specification = Dereferencer(specification_url)()
    raise
    # TODO: уточнить как их различать
    # if 'swagger' in specification:
    #     return SwaggerParser(specification, specification_url)
    # if 'openapi' in specification:
    #     return OpenApiParser(specification, specification_url)
    # raise ValueError()
